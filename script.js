const reviewOffsets = [0, 1, 3, 6, 14, 29, 44];
let allSchedules = JSON.parse(localStorage.getItem('schedules') || '[]');
let pooledTasks = JSON.parse(localStorage.getItem('pooledTasks') || '[]');
let poolCapacity = parseInt(localStorage.getItem('poolCapacity') || '10', 10); // ÈªòËÆ§10

function saveData() {
    localStorage.setItem('schedules', JSON.stringify(allSchedules));
    localStorage.setItem('pooledTasks', JSON.stringify(pooledTasks));
    localStorage.setItem('poolCapacity', poolCapacity);
    autoSyncToGist();
}

function autoSyncToGist() {
    const { token, gistId } = loadGistConfig();
    if (!token || !gistId) return;
    const exportData = {
        schedules: allSchedules,
        pooledTasks: pooledTasks,
        poolCapacity: poolCapacity
    };
    fetch(`https://api.github.com/gists/${gistId}`, {
        method: 'PATCH',
        headers: {
            'Authorization': 'token ' + token,
            'Accept': 'application/vnd.github.v3+json'
        },
        body: JSON.stringify({
            files: {
                "review_schedule.json": {
                    content: JSON.stringify(exportData, null, 2)
                }
            }
        })
    }).then(res => {
        if (res.ok) {
            showToast('ÂêåÊ≠•Âà∞‰∫ëÁ´ØÊàêÂäüÔºÅ');
        }
    });
}

setInterval(() => {
    downloadData();
}, 86400000);

const normalReviewOffsets = [0, 1, 3, 6, 14, 29, 44];
const quickReviewOffsets = [0, 3, 6, 14, 29];

function addSchedule() {
    const name = document.getElementById("eventName").value.trim();
    const startDateStr = document.getElementById("startDate").value;
    const reviewMode = document.getElementById("reviewMode").value;
    const priority = document.getElementById("priority") ? document.getElementById("priority").value : "low";
    
    if (!name || !startDateStr) {
        alert("ËØ∑Â°´ÂÜôÂêçÁß∞ÂíåÂºÄÂßãÊó∂Èó¥");
        return;
    }

    const startDate = new Date(startDateStr);
    let scheduleQueue = [];
    
    let selectedOffsets;
    switch(reviewMode) {
        case 'quick':
            selectedOffsets = quickReviewOffsets;
            break;
        case 'single':
            selectedOffsets = [0];
            break;
        default:
            selectedOffsets = normalReviewOffsets;
    }

    selectedOffsets.forEach((offset, index) => {
        const reviewDate = new Date(startDate);
        reviewDate.setDate(reviewDate.getDate() + offset);
        scheduleQueue.push({
            name,
            round: index + 1,
            date: reviewDate.toISOString().split('T')[0],
            completed: false,
            priority // Êñ∞Â¢û‰ºòÂÖàÁ∫ß
        });
    });

    scheduleQueue.forEach(schedule => {
        let currentDate = new Date(schedule.date);
        let targetDate = currentDate.toISOString().split('T')[0];
        let tryCount = 0;
        // Êñ∞Â¢ûÔºöÊúÄÂ§öÂè™ÂÖÅËÆ∏ËøûÁª≠‰∏§Â§©Ë∑≥ËøáÔºåÁ¨¨‰∏âÂ§©ÂøÖÈ°ªÊèíÂÖ•
        while (allSchedules.filter(item => item.date === targetDate).length >= 5 && tryCount < 2) {
            currentDate.setDate(currentDate.getDate() + 1);
            targetDate = currentDate.toISOString().split('T')[0];
            tryCount++;
        }
        // Á¨¨‰∏âÂ§©ÔºàtryCount==2ÔºâÊó†ËÆ∫ÊòØÂê¶Â∑≤Êª°ÈÉΩÊèíÂÖ•
        allSchedules.push({
            name: schedule.name,
            round: schedule.round,
            date: targetDate,
            completed: schedule.completed,
            priority: schedule.priority
        });
    });

    saveData();
    showToast("Â∑≤Ê∑ªÂä†Êó•Á®ãÂπ∂ÁîüÊàêÂ§ç‰π†ËÆ°ÂàíÔºÅ");
    renderSchedule();
}

function renderSchedule() {
    const viewMonth = document.getElementById("viewMonth").value;
    if (!viewMonth) return;

    const [year, month] = viewMonth.split("-");
    const firstDay = new Date(year, month - 1, 1);
    const lastDay = new Date(year, month, 0).getDate();
    const firstDayWeekday = firstDay.getDay();

    let calendar = {};
    allSchedules.forEach((item, idx) => {
        if (item.date.startsWith(viewMonth)) {
            if (!calendar[item.date]) calendar[item.date] = [];
            calendar[item.date].push({ ...item, index: idx });
        }
    });

    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];

    let html = `<table class="calendar-table"><thead><tr>`;
    ["Êó•", "‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠"].forEach(day => {
        html += `<th>${day}</th>`;
    });
    html += `</tr></thead><tbody>`;

    let dayCounter = 1;
    for (let row = 0; row < 5; row++) {
        html += `<tr>`;
        for (let col = 0; col < 7; col++) {
            if (row === 0 && col < firstDayWeekday) {
                html += `<td></td>`;
            } else if (dayCounter <= lastDay) {
                const dateStr = `${year}-${month}-${String(dayCounter).padStart(2, '0')}`;
                const items = calendar[dateStr] || [];
                const content = items.map(item => {
                    const titleStyle = item.round === 1 ? 'style="color: #4CAF50;"' : '';
                    const priorityClass = item.priority === "high" ? "priority-high" : (item.priority === "medium" ? "priority-medium" : "");
                    const priorityIcon = item.priority === "high" ? "üî•" : (item.priority === "medium" ? "‚≠ê" : "");
                    return `<div class="${item.completed ? 'completed' : 'drop-target'} draggable task-item ${priorityClass}" draggable="true"
                ondragstart="handleDragStart(event, ${item.index})">
                <input type="checkbox" onchange="toggleComplete(${item.index})" ${item.completed ? 'checked' : ''}>
                <span ${titleStyle}>${priorityIcon}${item.name}-R${item.round}</span>
              </div>`;
                }).join("");
                const rowClass = content ? (dateStr === todayStr ? 'highlight' : '') : 'no-task-row';

                html += `<td class="${rowClass}" ondrop="handleDrop(event, '${dateStr}')" ondragover="allowDrop(event)">
              <div style="font-weight: bold">${dayCounter}</div><br>${content}</td>`;
                dayCounter++;
            } else {
                html += `<td></td>`;
            }
        }
        html += `</tr>`;
    }
    html += `</tbody></table>`;

    document.getElementById("calendar").innerHTML = html;
    updateStats();
    renderTaskPool(); // Ê∑ªÂä†Ëøô‰∏ÄË°å
}

function handleDragStart(event, index) {
    event.dataTransfer.setData("text", index);
}

function allowDrop(event) {
    event.preventDefault();
}

function handleDrop(event, targetDate) {
    event.preventDefault();
    const draggedIndex = event.dataTransfer.getData("text");
    const source = event.dataTransfer.getData("source") || "schedule";

    if (source === "schedule") {
        const draggedSchedule = allSchedules[draggedIndex];
        const newDate = new Date(targetDate);
        draggedSchedule.date = newDate.toISOString().split('T')[0];
    } else if (source === "pool") {
        const draggedTask = pooledTasks[draggedIndex];
        pooledTasks.splice(draggedIndex, 1);
        allSchedules.push({
            ...draggedTask,
            date: targetDate
        });
    }

    saveData();
    renderSchedule();
    renderTaskPool();
}

function handlePoolDrop(event) {
    event.preventDefault();
    if (pooledTasks.length >= poolCapacity) {
        showToast('‰ªªÂä°Ê±†Â∑≤ËææÂÆπÈáè‰∏äÈôêÔºåÊó†Ê≥ïÁªßÁª≠Ê∑ªÂä†‰ªªÂä°ÔºÅ');
        return;
    }
    const draggedIndex = event.dataTransfer.getData("text");
    const draggedSchedule = allSchedules[draggedIndex];

    pooledTasks.push({
        name: draggedSchedule.name,
        round: draggedSchedule.round,
        completed: draggedSchedule.completed,
        priority: draggedSchedule.priority // ‰øùËØÅ‰ºòÂÖàÁ∫ß‰∏ç‰∏¢Â§±
    });

    allSchedules.splice(draggedIndex, 1);

    saveData();
    renderSchedule();
    renderTaskPool();
}

function handleDragStart(event, index, source = "schedule") {
    event.dataTransfer.setData("text", index);
    event.dataTransfer.setData("source", source);
}

function renderTaskPool() {
    const poolHtml = pooledTasks.map((task, index) => {
        const priorityClass = task.priority === "high" ? "priority-high" : (task.priority === "medium" ? "priority-medium" : "");
        const priorityIcon = task.priority === "high" ? "üî•" : (task.priority === "medium" ? "‚≠ê" : "");
        return `<div class="task-item ${priorityClass}" draggable="true" 
             ondragstart="handleDragStart(event, ${index}, 'pool')">
            <span>${priorityIcon}${task.name}-R${task.round}</span>
        </div>`;
    }).join('');

    document.getElementById("taskPool").innerHTML = poolHtml || '<p>ÊöÇÊó†ÂæÖÂ§ÑÁêÜÁöÑ‰ªªÂä°</p>';
    // ÊòæÁ§∫ÂÆπÈáè‰ø°ÊÅØ
    const info = `(${pooledTasks.length} / ${poolCapacity})`;
    document.getElementById('poolCapacityInfo').textContent = info;
    document.getElementById('poolCapacity').value = poolCapacity;
}

function toggleComplete(index) {
    allSchedules[index].completed = !allSchedules[index].completed;
    saveData();
    renderSchedule();
}

function updateStats() {
    const totalTasks = allSchedules.length;
    const completedTasks = allSchedules.filter(item => item.completed).length;
    const uncompletedTasks = totalTasks - completedTasks;

    if (totalTasks === 0) {
        document.getElementById("stats").innerHTML = `
      <p>Ê≤°ÊúâÂ§ç‰π†ËÆ°Âàí„ÄÇ</p>
    `;
        return;
    }

    const latestSchedule = allSchedules.reduce((latest, item) => {
        const itemDate = new Date(item.date);
        return itemDate > latest ? itemDate : latest;
    }, new Date(0));

    const earliestSchedule = allSchedules.reduce((earliest, item) => {
        const itemDate = new Date(item.date);
        return itemDate < earliest ? itemDate : earliest;
    }, new Date());

    const latestScheduleDate = latestSchedule.toISOString().split('T')[0];
    const earliestScheduleDate = earliestSchedule.toISOString().split('T')[0];

    const timeDifference = Math.floor((latestSchedule - earliestSchedule) / (1000 * 60 * 60 * 24));

    const fifthRoundSchedules = allSchedules.filter(item => item.round === 5);
    const lastFifthRound = fifthRoundSchedules.reduce((latest, item) => {
        const itemDate = new Date(item.date);
        return itemDate > latest ? itemDate : latest;
    }, new Date(0));

    const fifthRoundTimeDifference = Math.floor((lastFifthRound - earliestSchedule) / (1000 * 60 * 60 * 24));

    const todayStr = new Date().toISOString().split('T')[0];
    const todayTasks = allSchedules.filter(item => item.date === todayStr && !item.completed).length;

    const completionRate = totalTasks ? ((completedTasks / totalTasks) * 100).toFixed(2) : 0;

    const progressBarWidth = 300;
    const progressWidth = Math.round((completedTasks / totalTasks) * progressBarWidth);

    const statsHtml = `
    <p>ÊÄª‰ªªÂä°Êï∞Ôºö${totalTasks}</p>
    <p>Â∑≤ÂÆåÊàêÔºö${completedTasks} | Êú™ÂÆåÊàêÔºö${uncompletedTasks}</p>
    <p style="color:#4CAF50;">ÊúÄÊôöÂ§ç‰π†Êó•Á®ãÔºö${latestScheduleDate}</p>
    <p style="color:#4CAF50;">ÂÆåÊàêÊâÄÊúâÂ§ç‰π†ÊâÄÈúÄÊó∂Èó¥Ôºö${timeDifference} Â§©</p>
    <p style="color:#4CAF50;">ÂÆåÊàêÁ¨¨‰∫îËΩÆÂ§ç‰π†ÊâÄÈúÄÊó∂Èó¥Ôºö${fifthRoundTimeDifference} Â§©</p>
    <p>ÂÆåÊàêÁéáÔºö${completionRate}%</p>
    <div class="progress-bar">
      <div class="progress" style="width: ${progressWidth}px;"></div>
    </div>
    <br>
    <details>
      <summary>Â§ç‰π†ÊÄùË∑ØÂèÇËÄÉ:</summary>
      <p>Á¨¨‰∏ÄÈÅçR1 ËøáËÆ≤‰πâ ÊåñÁ©∫ 1<br>
      Á¨¨‰∫åÈÅçR2 ÂÅöÈ¢ò 2<br>
      Á¨¨‰∏âÈÅçR3 ËÆ≤‰πâ 4<br>
      Á¨¨ÂõõÈÅçR4 ÊÄùÁª¥ÂØºÂõæËØæ7<br>
      Á¨¨‰∫îÈÅçR5 ÂÅöÈ¢ò Êï¥ÁêÜËá™Â∑±ÁöÑanki 15<br>
      Á¨¨ÂÖ≠ÈÅçR6 ÂØºÂõæËØæ 30<br>
      Á¨¨‰∏ÉÈÅçR7 ÂØºÂõæorËÆ≤‰πâ + ÂÅöÈ¢ò ÊéíÈô§ÊúÄËøë‰∫îÂπ¥ÁöÑÈ¢òÁõÆ 45</p>
    </details>
  `;
    document.getElementById("stats").innerHTML = statsHtml;
}

function downloadData() {
    const exportData = {
        schedules: allSchedules,
        pooledTasks: pooledTasks
    };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
    const link = document.createElement('a');
    link.setAttribute("href", dataStr);
    link.setAttribute("download", "review_schedule.json");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function luckyDraw() {
    if (pooledTasks.length === 0) {
        showToast("‰ªªÂä°Ê±†‰∏≠Ê≤°ÊúâÂèØÊäΩÂèñÁöÑ‰ªªÂä°ÔºÅ");
        return;
    }

    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    
    // Ê£ÄÊü•‰ªäÂ§©ÁöÑ‰ªªÂä°Êï∞Èáè
    const todayTasks = allSchedules.filter(task => task.date === todayStr).length;
    // ÈöèÊú∫ÈÄâÊã©‰∏Ä‰∏™‰ªªÂä°
    const randomIndex = Math.floor(Math.random() * pooledTasks.length);
    const luckyTask = pooledTasks[randomIndex];
    
    // ‰ªé‰ªªÂä°Ê±†‰∏≠ÁßªÈô§ËØ•‰ªªÂä°
    pooledTasks.splice(randomIndex, 1);
    
    // Ê∑ªÂä†Âà∞‰ªäÂ§©ÁöÑÊó•Á®ã‰∏≠
    allSchedules.push({
        ...luckyTask,
        date: todayStr
    });

    saveData();
    renderSchedule();
    renderTaskPool();
    showToast(`Â∑≤Â∞Ü‰ªªÂä° "${luckyTask.name}-R${luckyTask.round}" Ê∑ªÂä†Âà∞‰ªäÂ§©ÁöÑÊó•Á®ã‰∏≠ÔºÅ`);
}

function uploadData(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const importedData = JSON.parse(e.target.result);
            if (importedData.schedules && Array.isArray(importedData.schedules)) {
                // ÂÖºÂÆπÊóßÊï∞ÊçÆÔºö‰∏∫Ê≤°Êúâ priority Â≠óÊÆµÁöÑ‰ªªÂä°ËµãÈªòËÆ§ÂÄº
                allSchedules = importedData.schedules.map(item => ({
                    ...item,
                    priority: item.priority || "low"
                }));
                if (importedData.pooledTasks && Array.isArray(importedData.pooledTasks)) {
                    pooledTasks = importedData.pooledTasks.map(item => ({
                        ...item,
                        priority: item.priority || "low"
                    }));
                }
                saveData();
                showToast("Êï∞ÊçÆÂØºÂÖ•ÊàêÂäüÔºÅ");
                renderSchedule();
            } else if (Array.isArray(importedData)) {
                // ÂÖºÂÆπÊõ¥Êó©ÁöÑÊóßÁâàÊú¨Ê†ºÂºè
                allSchedules = importedData.map(item => ({
                    ...item,
                    priority: item.priority || "low"
                }));
                saveData();
                showToast("Êï∞ÊçÆÂØºÂÖ•ÊàêÂäüÔºÅÔºàÊóßÁâàÊú¨Ê†ºÂºèÔºâ");
                renderSchedule();
            } else {
                alert("ÂØºÂÖ•ÁöÑÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºÅ");
            }
        } catch (err) {
            alert("ËØªÂèñÊñá‰ª∂Êó∂Âá∫ÈîôÔºö" + err.message);
        }
    };
    reader.readAsText(file);
}

function updateCountdown() {
    const examDate = new Date('2025-12-20T00:00:00+08:00');
    const now = new Date();
    const timeDifference = examDate - now;

    const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);

    document.getElementById("countdown").innerHTML = `
    <strong>ËÄÉÁ†îÂÄíËÆ°Êó∂Ôºö</strong> ${days}Â§© ${hours}Â∞èÊó∂ ${minutes}ÂàÜÈíü ${seconds}Áßí
  `;
}

function updateTodayInfo() {
    const today = new Date();
    const daysOfWeek = ['ÊòüÊúüÂ§©', 'ÊòüÊúü‰∏Ä', 'ÊòüÊúü‰∫å', 'ÊòüÊúü‰∏â', 'ÊòüÊúüÂõõ', 'ÊòüÊúü‰∫î', 'ÊòüÊúüÂÖ≠'];
    const todayStr = `${today.getFullYear()}Âπ¥${today.getMonth() + 1}Êúà${today.getDate()}Êó•`;
    const weekDay = daysOfWeek[today.getDay()];
    document.getElementById("todayInfo").innerHTML = `‰ªäÂ§©ÊòØÔºö${todayStr} ${weekDay}`;
}

function exportToICS() {
    if (allSchedules.length === 0) {
        alert("ÊöÇÊó†Êó•Á®ãÊï∞ÊçÆÂèØÂØºÂá∫");
        return;
    }

    let icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Ebbinghaus Review Helper//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
`;

    let existingUIDs = new Set();

    allSchedules.forEach(item => {
        const dateStr = item.date.replace(/-/g, '');
        const start = `${dateStr}`;
        const end = `${dateStr}`;
        const uid = `${start}-${item.name}`;

        if (existingUIDs.has(uid)) {
            return;
        }

        existingUIDs.add(uid);

        icsContent += `BEGIN:VEVENT
SUMMARY:${item.name}ÔºàÁ¨¨${item.round}Ê¨°Â§ç‰π†Ôºâ
DTSTART;TZID=Asia/Shanghai;VALUE=DATE:${start}
DTEND;TZID=Asia/Shanghai;VALUE=DATE:${end}
DESCRIPTION:ËâæÂÆæÊµ©ÊñØËÆ∞ÂøÜÊõ≤Á∫øÂ§ç‰π†Âä©ÊâãÊèêÈÜí
STATUS:CONFIRMED
SEQUENCE:0
UID:${uid}
BEGIN:VALARM
TRIGGER:-PT10M
ACTION:DISPLAY
DESCRIPTION:ÊèêÈÜí‰Ω†Â§ç‰π†„Äê${item.name}„Äë
END:VALARM
END:VEVENT
`;
    });

    icsContent += `END:VCALENDAR`;

    const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'review_schedule.ics';
    link.click();
}

let previousSchedules = [];

function skipToday() {
    if (allSchedules.length === 0) {
        alert("ÊöÇÊó†Êó•Á®ãÊï∞ÊçÆÂèØÊìç‰Ωú");
        return;
    }

    previousSchedules = JSON.parse(JSON.stringify(allSchedules));

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    allSchedules.forEach(item => {
        const itemDate = new Date(item.date);

        if (itemDate >= today && !item.completed) {
            itemDate.setDate(itemDate.getDate() + 1);
            item.date = itemDate.toISOString().split('T')[0];
        }
    });

    saveData();
    renderSchedule();
    alert("ÊâÄÊúâ‰ªäÂ§©Âèä‰ª•ÂêéÊó•Á®ãÂ∑≤Êé®Ëøü‰∏ÄÂ§©ÔºÅ");
}

function undoSkipToday() {
    if (previousSchedules.length === 0) {
        alert("Ê≤°ÊúâÂèØÊí§ÈîÄÁöÑÊìç‰Ωú");
        return;
    }

    allSchedules = previousSchedules;
    saveData();
    renderSchedule();
    showToast("Êìç‰ΩúÂ∑≤Êí§ÈîÄÔºåÊó•Á®ãÊÅ¢Â§çÂà∞ÂéüÁä∂ÊÄÅ");
}

function deleteSchedulesByName() {
    const nameToDelete = document.getElementById("deleteEventName").value.trim();

    if (!nameToDelete) {
        alert("ËØ∑Â°´ÂÜôÊó•Á®ãÂêçÁß∞");
        return;
    }

    const initialScheduleCount = allSchedules.length;
    allSchedules = allSchedules.filter(schedule =>
        schedule.name !== nameToDelete || schedule.completed === true
    );

    const deletedSchedules = initialScheduleCount - allSchedules.length;

    if (deletedSchedules === 0) {
        alert("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊó•Á®ãÂêçÁß∞ÔºåÊàñËÄÖÊâÄÊúâÂåπÈÖçÁöÑÊó•Á®ãÂ∑≤ÂÆåÊàê");
    } else {
        saveData();
        showToast(`Â∑≤Âà†Èô§ÊâÄÊúâÊú™ÂÆåÊàêÁöÑÂêçÁß∞‰∏∫ "${nameToDelete}" ÁöÑÊó•Á®ã`);
        renderSchedule();
    }
}

// Êñ∞Â¢ûÔºöÊåâÂêçÁß∞ÂíåÂèØÈÄâËΩÆÊ¨°Âà†Èô§ÂçïÊ¨°Êó•Á®ã
function deleteScheduleByNameAndOptionalRound() {
    const nameToDelete = document.getElementById("deleteEventName").value.trim();
    const roundStr = document.getElementById("deleteEventRound").value.trim();
    const roundToDelete = roundStr ? parseInt(roundStr, 10) : null;

    if (!nameToDelete) {
        alert("ËØ∑Â°´ÂÜôÊó•Á®ãÂêçÁß∞");
        return;
    }

    if (roundToDelete !== null && !isNaN(roundToDelete)) {
        // Âà†Èô§ÂçïÊ¨°ÔºàÂêçÁß∞+ËΩÆÊ¨°Ôºâ
        const index = allSchedules.findIndex(schedule =>
            schedule.name === nameToDelete &&
            schedule.completed === false &&
            schedule.round === roundToDelete
        );
        const poolIndex = pooledTasks.findIndex(task =>
            task.name === nameToDelete &&
            task.round === roundToDelete
        );
        if (index === -1 && poolIndex === -1) {
            alert("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊó•Á®ãÔºåÊàñËÄÖËØ•Êó•Á®ãÂ∑≤ÂÆåÊàê");
        } else {
            if (index !== -1) {
                allSchedules.splice(index, 1);
            }
            if (poolIndex !== -1) {
                pooledTasks.splice(poolIndex, 1);
            }
            saveData();
            showToast(`Â∑≤Âà†Èô§ÂêçÁß∞‰∏∫ "${nameToDelete}"ÔºåÁ¨¨${roundToDelete}ËΩÆÁöÑ‰∏Ä‰∏™Êú™ÂÆåÊàêÊó•Á®ãÔºàÂê´‰ªªÂä°Ê±†Ôºâ`);
            renderSchedule();
            renderTaskPool();
        }
    } else {
        // Âà†Èô§ÊâÄÊúâËØ•ÂêçÁß∞ÁöÑÊú™ÂÆåÊàêÊó•Á®ã
        const beforeLength = allSchedules.length;
        const beforePoolLength = pooledTasks.length;
        allSchedules = allSchedules.filter(schedule =>
            !(schedule.name === nameToDelete && schedule.completed === false)
        );
        pooledTasks = pooledTasks.filter(task =>
            task.name !== nameToDelete
        );
        const deletedCount = (beforeLength - allSchedules.length) + (beforePoolLength - pooledTasks.length);
        if (deletedCount === 0) {
            alert("Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊú™ÂÆåÊàêÊó•Á®ã");
        } else {
            saveData();
            showToast(`Â∑≤Âà†Èô§ÂêçÁß∞‰∏∫ "${nameToDelete}" ÁöÑ${deletedCount}‰∏™Êú™ÂÆåÊàêÊó•Á®ãÔºàÂê´‰ªªÂä°Ê±†Ôºâ`);
            renderSchedule();
            renderTaskPool();
        }
    }
}

document.getElementById('clear-all-schedules').addEventListener('click', function() {
    const confirmClear = confirm("‰Ω†Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÊó•Á®ãÂêóÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄÔºÅ");

    if (confirmClear) {
        allSchedules = [];
        pooledTasks = []; // ÂêåÊó∂Ê∏ÖÁ©∫‰ªªÂä°Ê±†
        saveData();
        renderSchedule();
        showToast('ÊâÄÊúâÊó•Á®ãÂ∑≤Ê∏ÖÁ©∫ÔºÅ');
    }
});

window.onload = async () => {
    updateCountdown();
    updateTodayInfo();

    const today = new Date();
    document.getElementById("startDate").valueAsDate = today;

    const currentMonth = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
    document.getElementById("viewMonth").value = currentMonth;

    setInterval(updateCountdown, 1000);
    setInterval(updateTodayInfo, 1000);

    // ÂÖàÂ∞ùËØï‰ªé‰∫ëÁ´ØÂêåÊ≠•Êï∞ÊçÆ
    await syncFromGist();

    renderSchedule();
};

function setPoolCapacity() {
    const val = parseInt(document.getElementById('poolCapacity').value, 10);
    if (isNaN(val) || val <= 0) {
        alert('ËØ∑ËæìÂÖ•Â§ß‰∫é0ÁöÑÊï∞Â≠ó‰Ωú‰∏∫ÂÆπÈáèÔºÅ');
        return;
    }
    poolCapacity = val;
    saveData();
    renderTaskPool();
}

// ÂêåÊ≠•Âà∞ GitHub Gist
async function syncToGist() {
    const token = document.getElementById('gistToken').value.trim();
    const gistId = document.getElementById('gistId').value.trim();
    if (!token || !gistId) {
        alert('ËØ∑Â°´ÂÜô GitHub Token Âíå Gist ID');
        return;
    }
    const exportData = {
        schedules: allSchedules,
        pooledTasks: pooledTasks,
        poolCapacity: poolCapacity
    };
    try {
        const res = await fetch(`https://api.github.com/gists/${gistId}`, {
            method: 'PATCH',
            headers: {
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                files: {
                    "review_schedule.json": {
                        content: JSON.stringify(exportData, null, 2)
                    }
                }
            })
        });
        if (res.ok) {
            showToast('ÂêåÊ≠•Âà∞‰∫ëÁ´ØÊàêÂäüÔºÅ');
        } else {
            alert('ÂêåÊ≠•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü• Token Âíå Gist ID ÊòØÂê¶Ê≠£Á°Æ');
        }
    } catch (err) {
        alert('ÂêåÊ≠•Âá∫ÈîôÔºö' + err.message);
    }
}

// ‰ªé GitHub Gist ÂêåÊ≠•
async function syncFromGist() {
    const { token, gistId } = loadGistConfig();
    if (!token || !gistId) return;
    try {
        const res = await fetch(`https://api.github.com/gists/${gistId}`, {
            headers: {
                'Authorization': 'token ' + token,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        const data = await res.json();
        if (data.files && data.files["review_schedule.json"]) {
            const importedData = JSON.parse(data.files["review_schedule.json"].content);

            // Ê∑±Â∫¶ÊØîËæÉ
            const localData = {
                schedules: allSchedules,
                pooledTasks: pooledTasks,
                poolCapacity: poolCapacity
            };
            const isSame = JSON.stringify(importedData) === JSON.stringify(localData);

            if (!isSame) {
                allSchedules = importedData.schedules || [];
                pooledTasks = importedData.pooledTasks || [];
                poolCapacity = importedData.poolCapacity || 10;
                saveData();
                renderSchedule();
                showToast('‰ªé‰∫ëÁ´ØÂêåÊ≠•ÊàêÂäüÔºÅ');
            }
            // Â¶ÇÊûúÂÆåÂÖ®‰∏ÄÊ†∑Ôºå‰∏çÂÅö‰ªª‰ΩïÊìç‰Ωú
        }
    } catch (err) {
        // ÂèØÈÄâÔºöÈîôËØØÂ§ÑÁêÜ
    }
}

function saveGistConfig() {
    const token = document.getElementById('gistToken').value.trim();
    const gistId = document.getElementById('gistId').value.trim();
    if (!token || !gistId) {
        alert('ËØ∑Â°´ÂÜô GitHub Token Âíå Gist ID');
        return;
    }
    localStorage.setItem('gistToken', token);
    localStorage.setItem('gistId', gistId);
    showToast('‰∫ëÁ´ØÈÖçÁΩÆÂ∑≤‰øùÂ≠òÔºå‰∏ãÊ¨°Ëá™Âä®Â°´ÂÖÖÔºÅ');
}

function loadGistConfig() {
    const token = localStorage.getItem('gistToken') || '';
    const gistId = localStorage.getItem('gistId') || '';
    document.getElementById('gistToken').value = token;
    document.getElementById('gistId').value = gistId;
    return { token, gistId };
}

function showToast(message) {
    const toast = document.getElementById('toast');
    if (!toast) return;
    toast.textContent = message;
    toast.style.display = 'block';
    toast.style.opacity = '1';
    setTimeout(() => {
        toast.style.transition = 'opacity 0.5s';
        toast.style.opacity = '0';
        setTimeout(() => {
            toast.style.display = 'none';
            toast.style.transition = '';
        }, 500);
    }, 3000);
}